1)                      
  a)  iterative approach
________________________________________

#include <stdio.h>
int pow_custom(int x, int i) {
    int pow = 1;
    for (int j = 0; j < i; j++) {
        pow *= x;
    }
    return pow;
}
int* cal(int* sum, int x, int r) {
    for (int i = 0; i < r; i++) {
        int p = pow_custom(x, i);
        printf("*sum=%d pow(%d,%d)=%d\n", *sum, x, i, p);
        *sum += p;
    }
    return sum;
}
int main() {
    int x, r;
    printf("Enter the number to find its power = ");
    scanf("%d", &x);
    printf("Enter till how many times the power should be calculated = ");
    scanf("%d", &r);
    int sum = 0;
    cal(&sum, x, r);
    printf("The sum is = %d\n", sum);
    return 0;
}

b) recursive approach
______________________________________________________

#include <stdio.h>
int power(int x, int r) {
    if (r == 0) {
        return 1;
    }
    return x * power(x, r - 1);
}

int calculateSum(int x, int r) {
    if (r == 0) {
        return 1;
    }
    return calculateSum(x, r - 1) + power(x, r);
}

int main() {
    int x, r;

    printf("Enter the number to find its power = ");
    scanf("%d", &x);

    printf("Enter till how many times the power should be calculated = ");
    scanf("%d", &r);
    int result = calculateSum(x, r - 1);

    printf("The sum is = %d\n", result);

    return 0;
}


c) GP formula approach
_____________________________________________________

#include <stdio.h>
#include <math.h>
int Algo1_SumGeoSeries(int a, int r, int n) {
    if (r == 1)
        return a * n;
    return (a * (pow(r, n) - 1)) / (r - 1);
}
int main() {
    int a, r, n;
    printf("The first term of the GP = ");
    scanf("%d", &a);
    printf("The common ratio = ");
    scanf("%d", &r);
    printf("The number of terms = ");
    scanf("%d", &n);
    int result = Algo1_SumGeoSeries(a, r, n);
    printf("Sum of geometric progression = %d\n", result);
    return 0;
}

2)        BST
______________________________________________________________

#include<stdio.h> 
#include<stdlib.h> 
struct node{ 
struct node *lchild; 
int data; 
struct node *rchild; 
}; 
struct node *root=NULL; 
struct node * create_node(int n){ 
struct node * new_node=(struct node *)malloc(sizeof(struct node)); 
new_node->data=n; 
new_node->lchild=NULL; 
new_node->rchild=NULL; 
return new_node; 
} 
struct node* min_val(struct node* root){ 
struct node* current = root; 
while(current && current->lchild != NULL){ 
current = current->lchild; 
} 
return current; 
} 
struct node *delete_node(struct node *root,int key){ 
if(root==NULL){ 
return NULL; 
} 
else if(key<root->data){ 
root->lchild =delete_node(root->lchild, key); 
} 
else if(key>root->data){ 
root->rchild =delete_node(root->rchild,key); 
} 
else{ 
printf("Deleting the number=%d",root->data); 
if(root->lchild==NULL){ 
struct node* temp=root->rchild; 
free(root); 
return temp; 
} 
if(root->rchild==NULL){ 
struct node* temp=root->lchild; 
free(root); 
return temp; 
} 
struct node* temp=min_val(root->rchild); 
root->data=temp->data; 
root->rchild=delete_node(root->rchild, temp->data); 
} 
return root; 
} 
struct node* search_bst(struct node* root,int n){ 
if(root==NULL){ 
root=create_node(n); 
return root; 
} 
else{ 
struct node *current=root; 
struct node *parent=NULL; 
while(1){ 
          if(n<current->data){ 
                    parent=current; 
                    current=current->lchild; 
                if(current==NULL){ 
                        parent->lchild=create_node(n); 
                        return root; 
                    } 
                } 
                else{ 
                    parent=current; 
                    current=current->rchild; 
                    if(current==NULL){ 
                        parent->rchild=create_node(n); 
                        return root; 
                    } 
                } 
        } 
    } 
} 
void display(struct node *root){ 
    if(root==NULL){ 
        return; 
    } 
else{ 
display(root->lchild); 
printf("%d ",root->data); 
display(root->rchild); 
} 
} 
int main(){ 
int loop=1; 
while(loop){ 
printf("\n1.Create or Add value\n2.Print\n3.Delete number\n4.Exit\n"); 
int c; 
printf("Choose an option="); 
scanf("%d",&c); 
switch(c){ 
case 1:{ 
int n; 
printf("Enter the number you want to add="); 
scanf("%d",&n); 
root=search_bst(root,n); 
break; 
} 
case 2:{ 
printf("Inorder traversal: "); 
                display(root); 
                printf("\n"); 
                break; 
            } 
            case 3:{ 
                int key; 
                printf("Enter the number you want to delete = "); 
                scanf("%d",&key); 
                root=delete_node(root,key); 
                break; 
            } 
            case 4:{ 
                loop=0; 
            } 
            default:{ 
                printf("Invalid choice\n"); 
            } 
    } 
    } 
    return 0; 
}
